[[_bundling]]
=== Construyendo

Aunque hemos visto las maneras comunes de transferir los datos de Git a través de una red (HTTP, SSH, etc), hay otra manera de hacerlo que es más común y que puede resultar muy útil.

Git es capaz de ``construir'' sus datos en un único archivo. Esto puede ser de ayuda en varios escenarios. Quizás tu red está caída y quieres enviar los cambios a tus compañeros de trabajo. Quizás estas trabajando fuera de la central y no tienes acceso a la red local por razones de seguridad. Quizás tu wifi/ethernet se acaba de romper. Quizás no tienes acceso al servidor compartido en este momento, y quieres enviar un email a alguien con tus actualizaciones pero no quieres mandar 40 _commits_ a través de `format-patch`.

Esto es donde el comando `git bundle` puede ser de ayuda. El comando `bundle` hará un paquete con todo lo que normalmente se enviaría por la red con un `git push` en un archivo binario que puedes mandar por email a alguien o ponerlo en un pen drive, luego descontruirlo en otro repositorio.

Veamos un ejemplo sencillo. Digamos que tienes un repositorio con dos _commits_:

[source,console]
----
$ git log
commit 9a466c572fe88b195efd356c3f2bbeccdb504102
Author: Scott Chacon <schacon@gmail.com>
Date:   Wed Mar 10 07:34:10 2010 -0800

    second commit

commit b1ec3248f39900d2a406049d762aa68e9641be25
Author: Scott Chacon <schacon@gmail.com>
Date:   Wed Mar 10 07:34:01 2010 -0800

    first commit
----

Si quieres enviar ese repositorio a alguien y no tienes acceso al repositorio remoto al que lo quieres enviar, o simplemente no quieres crear un repositorio remoto, puedes construir el repositorio con `git bundle create'.

[source,console]
----
$ git bundle create repo.bundle HEAD master
Counting objects: 6, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (6/6), 441 bytes, done.
Total 6 (delta 0), reused 0 (delta 0)
----

Ahora tienes un archivo llamado `repo.bundle` que tiene todos los datos necesarios para recrear la rama `master` de tu repositorio. Con el comando `bundle` es necesario hacer una lista de todas las referencias o rangos específicos de _commits_ que quieres incluir. Si pretendes hacer esto para que lo clonen en otra parte, debes añadir `HEAD` como referencia como hemos hecho aquí.

Puedes enviar este archivo `repo.bundle`por email a alguien, o ponerlo en un pen drive y pasarlo.

Por otro lado, supón que te envían este archivo `repo.bundle` y quieres trabajar en el proyecto. Puedes clonar el archivo binario a un directorio, igual que harías con una URL.

[source,console]
----
$ git clone repo.bundle repo
Initialized empty Git repository in /private/tmp/bundle/repo/.git/
$ cd repo
$ git log --oneline
9a466c5 second commit
b1ec324 first commit
----

Si no incluyes las referencias a HEAD, tienes que especificar también `-b master` o cualquier rama que este incluida porque de otro modo no sabrá a que rama sacar.

Ahora digamos que tienes tres _commits_ aquí y quieres enviar los nuevos _commits_ de vuelta en un paquete en un pen drive o por email.

[source,console]
----
$ git log --oneline
71b84da last commit - second repo
c99cf5b fourth commit - second repo
7011d3d third commit - second repo
9a466c5 second commit
b1ec324 first commit
----

Primero necesitamos determinar el rango de _commits_ que queremos incluir en el paquete. A diferencia de los protocolos de red que resuelven por nosotros cuál es la cantidad mínima de datos que transferir, tenemos que averiguar esto manualmente. Entonces, puedes hacer lo mismo y hacer un paquete con el repositorio completo, que funcionará, pero también es mejor solo construir un paquete con la diferencia - sólo los tres _commits_ que hemos hecho localmente.

Para hacer esto, necesitarás recalcular la diferencia. Como describimos en <<_commit_ranges>>, puedes especificar el rango de _commits_ de varias formas. Para conseguir los tres _commits_ que tenemos en nuestra rama que no están en la rama que clonamos, podemos usar algo como `origin/master..master` o `master ^origin/master`. Puedes probar esto comando `log`. 


[source,console]
----
$ git log --oneline master ^origin/master
71b84da last commit - second repo
c99cf5b fourth commit - second repo
7011d3d third commit - second repo
----

Ahora tenemos la lista de _commits_ que queremos incluir en ese paquete, vamos a hacerlo. Ejecutamos el comando `git bundle create`, dándole el nombre que queremos que tengamos el archivo y el rango de _commits_ que queremos incluir.

[source,console]
----
$ git bundle create commits.bundle master ^9a466c5
Counting objects: 11, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (9/9), 775 bytes, done.
Total 9 (delta 0), reused 0 (delta 0)
----

Ahora tenemos un archivo `commits.bundle` en nuestro repositorio. Si lo cogemos y lo enviamos a nuestro compañero, puede importarlo al repositorio original, incluso si se ha hecho más trabajo en el mientras tanto.

Cuando le llegue en paquete, puede inspeccionarlo para ver que contiene antes de importarlo en su repositorio. El primer comando es `bundle verify` que verificará que es un paquete de Git válido y que tiene todos los ancestros necesarios para reconstruirlo correctamente.

[source,console]
----
$ git bundle verify ../commits.bundle
The bundle contains 1 ref
71b84daaf49abed142a373b6e5c59a22dc6560dc refs/heads/master
The bundle requires these 1 ref
9a466c572fe88b195efd356c3f2bbeccdb504102 second commit
../commits.bundle is okay
----

Si la persona que creo el paquete sólo lo hubiese hecho de los dos últimos _commits_ que hizo, en vez de con los tres, el repositorio original no podría importarlo, ya que le falta un requisito en el historial. El comando `verify` podría tener este resultado:

[source,console]
----
$ git bundle verify ../commits-bad.bundle
error: Repository lacks these prerequisite commits:
error: 7011d3d8fc200abe0ad561c011c3852a4b7bbe95 third commit - second repo
----

Sin embargo, nuestro primer paquete es válido, así que podemos traer los _commits_ que contiene. Si quieres ver las ramas incluidas que puedes importar, también hay un comando para hacer una lista de sus ``heads'':

[source,console]
----
$ git bundle list-heads ../commits.bundle
71b84daaf49abed142a373b6e5c59a22dc6560dc refs/heads/master
----

El subcomando `verify` te mostrará los ``heads'' también. El propósito es ver que puedes lo que vas a incorporar, así que puedes usar los comandos `fetch` o `pull` para importar los _commits_ de ese paquete. Aquí incorporaremos la rama `master` del paquete en una rama llamada `other-master` en nuestro repositorio:


[source,console]
----
$ git fetch ../commits.bundle master:other-master
From ../commits.bundle
 * [new branch]      master     -> other-master
----

Ahora que podemos ver que hemos importado los _commits_ en la rama `other-master` además de cualquier _commit_ que hayamos hecho mientras tanto en nuestra propia rama `master`.

[source,console]
----
$ git log --oneline --decorate --graph --all
* 8255d41 (HEAD, master) third commit - first repo
| * 71b84da (other-master) last commit - second repo
| * c99cf5b fourth commit - second repo
| * 7011d3d third commit - second repo
|/
* 9a466c5 second commit
* b1ec324 first commit
----

Así que, `git bundle` puede ser muy útil para compartir o hacer operaciones tipo red cuando no tienes la red apropiada o un repositorio compartido para hacerlo.
