[[_subtree_merge]]
===== Fusión Subárbol
// TODO revisar esta traducción

La idea de la fusión subárbol es que tienes dos proyectos, uno de los proyectos es un subdirectorio del otro. Cuando especificas una fusión subárbol, Git es a menudo suficientemente listo como para saber que uno de los proyectos es un subárbol del otro y fusionarlos correctamente.

Veamos un ejemplo para añadir un proyecto externo en un proyecto existente y luego fusionar el código del segundo proyecto en un subdirectorio del primero.

Primero añadimos la aplicación Rack a nuestro proyecto. La añadiremos como una repositorio remoto en nuestro propio proyecto y luego lo sacamos a su propia rama:

[source,console]
----
$ git remote add rack_remote https://github.com/rack/rack
$ git fetch rack_remote --no-tags
warning: no common commits
remote: Counting objects: 3184, done.
remote: Compressing objects: 100% (1465/1465), done.
remote: Total 3184 (delta 1952), reused 2770 (delta 1675)
Receiving objects: 100% (3184/3184), 677.42 KiB | 4 KiB/s, done.
Resolving deltas: 100% (1952/1952), done.
From https://github.com/rack/rack
 * [new branch]      build      -> rack_remote/build
 * [new branch]      master     -> rack_remote/master
 * [new branch]      rack-0.4   -> rack_remote/rack-0.4
 * [new branch]      rack-0.9   -> rack_remote/rack-0.9
$ git checkout -b rack_branch rack_remote/master
Branch rack_branch set up to track remote branch refs/remotes/rack_remote/master.
Switched to a new branch "rack_branch"
----

Ahora tenemos la raíz de proyecto Rack en nuestra rama `rack_branch` y nuestro proyecto en la rama `master`.
Si activas un rama y luego la otra, puedes ver que tienen distintas raíces de proyecto:

[source,console]
----
$ ls
AUTHORS         KNOWN-ISSUES   Rakefile      contrib         lib
COPYING         README         bin           example         test
$ git checkout master
Switched to branch "master"
$ ls
README
----

Esto es un concepto extraño. No todas las ramas en tu repositorio tienen que ser ramificaciones del mismo proyecto. No es común, ya que raramente es de ayuda, pero es relativamente fácil tener ramas en tu proyecto que tengan historiales completamente distintos.

En este caso, queremos incorporar el proyecto Rack en nuestro proyecto `master` como un subdirectorio. Podemos hacer esto en Git con `git read-tree`. Aprenderás más de `read-tree` y sus amigos en <<_git_internals>>, pero por ahora sólo necesitas saber que lee el árbol raíz de una rama en tu área de preparación y directorio de trabajo actual. Acabamos de saltar a la rama `master`, e incorporamos la rama `rack_brach` en el subdirectorio `rack` de nuestra rama `master` en nuestro proyecto principal:

[source,console]
----
$ git read-tree --prefix=rack/ -u rack_branch
----

Cuando hacemos el _commit_, parece que tenemos todos los archivos del proyecto Rack en ese subdirectorio - como si los hubiéramos copiado de un tarball.
Lo que es interesante es que podemos fusionar los cambios de una rama a otra fácilmente.
Así que, si se actualiza el proyecto Rack, podemos traer los cambios remotos activado esa rama y haciendo un `git pull`:

[source,console]
----
$ git checkout rack_branch
$ git pull
----

Entonces, podemos fusionar esos cambios en nuestra rama `master`.
Para incorporar esos cambios y prepoblar el mensaje del _commit_ usa la opción `--squash`, además opción de la estrategia recursiva de fusión `-Xsubtree`. (La estrategia recursiva se usa por defecto aquí, pero lo incluimos por claridad).

[source,console]
----
$ git checkout master
$ git merge --squash -s recursive -Xsubtree=rack  rack_branch
Squash commit -- not updating HEAD
Automatic merge went well; stopped before committing as requested
----

Todos los cambios del proyecto Rack se han fusionado y están listos para ser confirmados localmente.
También puedes hacer lo contrario - hacer cambios en el subdirectorio `rack` de tu rama `master` y luego fusionarlos en tu rama `rack_brach` para luego presentarlos a los responsables del proyecto o enviarlos al repositorio remoto.

Esto te proporciona una manera de tener un flujo de trabajo similar al flujo de trabajo de submódulos, sin usar submódulos (los veremos en <<_git_submodules>>). Podemos mantener ramas con otros proyectos relacionados en nuestro repositorio y hacer una fusión subárbol de los mismos en nuestro proyecto ocasionalmente. Esto tiene su lado bueno, como por ejemplo que todo el código esta confirmado en un mismo lugar. Sin embargo, tiene ciertas desventajas, como que es más complejo y más fácil cometer errores al reintegrar cambios o accidentalmente enviar una rama a un repositorio erróneo.

Otra cosa rara que ocurre es que para obtener un diff entre lo tienes en tu subdirectorio `rack` y el código en tu rama `rack_brach`- para ver si necesitas fusionarlos - no puedes usar el comando `diff` normal. En vez de eso, debes ejecutar el comando `git diff-tree` con la rama que quieres comparar:


[source,console]
----
$ git diff-tree -p rack_branch
----

O, para comparar lo que está en tu subdirectorio `rack` con lo que estaba en tu rama `master` en el servidor la última vez que recuperaste los datos, puedes ejecutar

[source,console]
----
$ git diff-tree -p rack_remote/master
----
