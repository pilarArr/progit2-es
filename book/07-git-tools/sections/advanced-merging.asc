[[_advanced_merging]]
=== Fusiones Avanzadas

La fusión en Git es normalmente sencilla. Como Git facilita que puedas fusionar una rama varias veces, esto conlleva que puedas tener una rama muy antigua que al mismo tiempo mantengas actualizada mientras trabajas en ella, resolviendo pequeños conflictos a menudo, en vez de que te sorprenda un gran problema al final de una serie.

Sin embargo, a veces ocurren conflictos complejos. A diferencia de otros sistemas de control de versiones, Git no intenta ser demasiado inteligente en la resolución de conflictos de fusión. La filosofía de Git es ser hábil determinando cuándo la resolución de una fusión es inequívoca, pero si hay un conflicto, no intenta resolverlo automáticamente. Por lo tanto, si esperas demasiado tiempo para fusionar dos ramas que divergen rápidamente, puedes encontrarte con algunos problemas.

En esta sección, repasaremos cuáles pueden ser algunas de esos problemas y que herramientas te ofrece Git para ayudarte a solucionar esas situaciones más delicadas. También veremos algunas fusiones no convencionales que puedes realizar, además de como deshacer fusiones que hayas hecho.

==== Conflictos de Fusión

Aunque hemos cubierto unos básicos en cómo resolver conflictos de fusión en <<_basic_merge_conflicts>>, para conflictos más complejos, Git ofrece una serie de herramientas para ayudarte a averiguar qué está pasando y cómo resolver mejor el conflicto.

Primero de todo, si fuese posible, intenta asegurarte de que tu directorio de trabajo esta limpio antes de hacer una fusión que pueda tener conflictos. Si tienes trabajo en progreso, haz un _commit_ en una rama temporal o haz un stash. De esta manera te aseguras de que puedes deshacer *cualquier cosa* que intentes a partir de ahora. Si tienes trabajo sin guardar en tu directorio de trabajo cuando intentes hacer una fusión, algunos de estos consejos pueden hacer que pierdas ese trabajo.

Veamos este ejemplo sencillo. Tenemos un archivo de Ruby muy simple que imprime 'hello world'.


[source,ruby]
----
#! /usr/bin/env ruby

def hello
  puts 'hello world'
end

hello()
----

En nuestro repositorio, creamos una nueva rama llamada `whitespace` y procedemos a cambiar todas las terminaciones de línea de Unix a terminaciones de línea de DOS, básicamente cambiando todas las líneas del archivo, pero sólo con espacio en blanco. Luego, cambiamos la línea ``hello world'' a ``hello mundo''.


[source,console]
----
$ git checkout -b whitespace
Switched to a new branch 'whitespace'

$ unix2dos hello.rb
unix2dos: converting file hello.rb to DOS format ...
$ git commit -am 'converted hello.rb to DOS'
[whitespace 3270f76] converted hello.rb to DOS
 1 file changed, 7 insertions(+), 7 deletions(-)

$ vim hello.rb
$ git diff -b
diff --git a/hello.rb b/hello.rb
index ac51efd..e85207e 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,7 @@
 #! /usr/bin/env ruby

 def hello
-  puts 'hello world'
+  puts 'hello mundo'^M
 end

 hello()

$ git commit -am 'hello mundo change'
[whitespace 6d338d2] hello mundo change
 1 file changed, 1 insertion(+), 1 deletion(-)
----

Ahora cambiamos a nuestra rama `master` y añadimos algo de documentación para la función.


[source,console]
----
$ git checkout master
Switched to branch 'master'

$ vim hello.rb
$ git diff
diff --git a/hello.rb b/hello.rb
index ac51efd..36c06c8 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
   puts 'hello world'
 end

$ git commit -am 'document the function'
[master bec6336] document the function
 1 file changed, 1 insertion(+)
----

Ahora intentamos fusionar nuestra rama `whitespace` y tendremos conflictos en la fusión debido a los cambios de espacio en blanco.

[source,console]
----
$ git merge whitespace
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.
----

[[_abort_merge]]
===== Cancelando una Fusión

Ahora tenemos unas cuantas opciones. Primero, veamos cómo salir de esta situación. Si tal vez no esperases conflictos y no quieres lidiar con la situación todavía, puedes simplemente deshacer la fusión con `git merge --abort`.

[source,console]
----
$ git status -sb
## master
UU hello.rb

$ git merge --abort

$ git status -sb
## master
----

La opción `git merge --abort` intenta volver al estado en que estabas antes de ejecutar la fusión. El único caso en el que quizás no puedas hacer esto perfectamente sería en el que tuvieses cambios sin confirmar y _unstashed_ en tu directorio de trabajo al ejecutar el comando, de otro modo, debería funcionar sin problemas.

Si por alguna razón sólo quieres volver a empezar, también puedes ejecutar `git reset --hard HEAD`, y tu repositorio volverá a la última instantánea confirmada. Recuerda que perderás cualquier trabajo sin confirmar, así que asegúrate que no quieres conservar ninguno de los cambios.


===== Ignorando el Espacio en Blanco

En este caso en concreto, el conflicto esta relacionado con el espacio en blanco. Lo sabemos porque este caso es sencillo, pero también es muy fácil darse cuenta en casos reales porque al revisar el conflicto se ve en un lado como todas las líneas has sido eliminadas y en el otro que han sido añadidas de nuevo. Por defecto, Git ve todas estas líneas como cambiadas, así que no puede fusionar los archivos.

La estrategia por defecto para la fusión acepta varias opciones, y algunas de ellas ayudan a ignorar correctamente los cambios en espacio en blanco. Si observas que tienes muchos problemas con espacio en blanco en una fusión, puedes simplemente cancelarla y hacerla otra vez, esta vez con `-Xignore-all-space` o `-Xignore-space-change`. La primera opción ignora los cambios en espacio en blanco *completamente* cuando compara las líneas, y la segunda trata las secuencias de uno o más caracteres de espacio en blanco como equivalentes.

[source,console]
----
$ git merge -Xignore-space-change whitespace
Auto-merging hello.rb
Merge made by the 'recursive' strategy.
 hello.rb | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
----

Ya que en este caso, los cambios al archivo no eran conflictivos, una vez ignoramos los cambio de espacio en blanco todo se fusiona sin problemas.

Esto es una gran ayuda si tienes a alguien en tu equipo a quien le gusta ocasionalmente reformatear todo los espacios a tabuladores o viceversa.

[[_manual_remerge]]
===== Refusionar un Archivo Manualmente

Aunque Git maneja el pre-procesado de espacio en blanco bastante bien, hay otros tipos de cambios que quizás Git no puede manejar automáticamente, pero que son arreglos que se pueden programar. Como ejemplo, pretendamos que Git no puede manejar el cambio de espacio en blanco y tenemos que hacerlo a mano.

Lo que necesitamos hacer es ejecutar el archivo que estamos fusionando a través de un programa `dos2unix` antes de fusionarlo. ¿Cómo hacemos esto?

Primero, entramos en el estado de conflicto de fusión. Luego queremos conseguir copias de mi versión del archivo, su versión (de la rama que estamos fusionando) y la versión en común (de cuando las ramas divergieron). Entonces queremos arreglar o su parte, o nuestra parte y reintentar la fusión de nuevo únicamente para este archivo. 

Conseguir las tres versiones del archivo es fácil. Git guarda todas estas versiones en el índice bajo ``etapas'' cada una de los cuáles tiene unos números asociados. La etapa 1 es el ancestro común, la etapa 2 es tu versión y la etapa 3 viene de `MERGE_HEAD`, la versión que estas fusionando (``la suya'').

Puedes extraer una copia de cada una de estas versiones del archivo conflictivo con el comando `git show` y una sintaxis especial.

[source,console]
----
$ git show :1:hello.rb > hello.common.rb
$ git show :2:hello.rb > hello.ours.rb
$ git show :3:hello.rb > hello.theirs.rb
----

Si quieres ir un poco más _hard core_, puedes usar el comando `ls-files -u` de fontanería para sacar los SHA-1s de los _blobs_ de Git de cada uno de estos archivos.

[source,console]
----
$ git ls-files -u
100755 ac51efdc3df4f4fd328d1a02ad05331d8e2c9111 1	hello.rb
100755 36c06c8752c78d2aff89571132f3bf7841a7b5c3 2	hello.rb
100755 e85207e04dfdd5eb0a1e9febbc67fd837c44a1cd 3	hello.rb
----

La sintaxis `:1:hello.rb` es solo una abreviación para buscar ese _blob_ SHA-1.

Ahora que ya tenemos el contenido de las tres etapas en nuestro directorio de trabajo, podemos arreglar manualmente su versión para solucionar el problema del espacio en blanco y refusionar el archivo con el poco conocido comando `git merge-file` que hace justamente eso.

[source,console]
----
$ dos2unix hello.theirs.rb
dos2unix: converting file hello.theirs.rb to Unix format ...

$ git merge-file -p \
    hello.ours.rb hello.common.rb hello.theirs.rb > hello.rb

$ git diff -b
diff --cc hello.rb
index 36c06c8,e85207e..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,8 -1,7 +1,8 @@@
  #! /usr/bin/env ruby

 +# prints out a greeting
  def hello
-   puts 'hello world'
+   puts 'hello mundo'
  end

  hello()
----

En este punto hemos fusionado correctamente el archivo. De hecho, esto parece funcionar mejor que la opción `ignore-space-change` ya que esto arregla los problemas con el espacio en blanco antes de hacer la fusión en vez de simplemente ignorarlos. En la fusión `ignore-space-change`, acabamos con unas pocas líneas con terminaciones DOS, mezclando resultados.

Si quieres tener una idea de lo que se ha cambiado realmente entre un lado o el otro antes de finalizar el _commit_, puedes preguntarle a `git diff` que compare lo que esta en tu directorio de trabajo y lo que vas a confirmar como resultado de la fusión con cualquiera de estas etapas. Vamos a revisarlas todas.

Para comparar tu resultado con lo tenias en tu rama antes de la fusión, o en otras palabras, para ver lo que la fusión introdujo, puedes ejecutar `git diff --ours`

[source,console]
----
$ git diff --ours
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index 36c06c8..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -2,7 +2,7 @@

 # prints out a greeting
 def hello
-  puts 'hello world'
+  puts 'hello mundo'
 end

 hello()
----

Así podemos ver fácilmente lo que pasó realmente en nuestra rama, lo que estamos introduciendo con esta fusión en este archivo, que es cambiar esa única línea.

Si queremos ver como el resultado de la fusión difiere de lo que estaba en su lado, podemos ejecutar `git diff --theirs`. En este y en el ejemplo siguiente, tenemos que usar `-b` para eliminar el espacio en blanco, ya que estamos comparándolo con lo que está en Git y no con nuestro archivo `hello.theirs.rb` limpio.

[source,console]
----
$ git diff --theirs -b
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index e85207e..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
   puts 'hello mundo'
 end
----

Finalmente, puedes ver como el archivo ha cambiado desde ambos lados con `git diff --base`.

[source,console]
----
$ git diff --base -b
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index ac51efd..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,8 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
-  puts 'hello world'
+  puts 'hello mundo'
 end

 hello()
----

Llegados a este punto podemos usar el comando `git clean` para limpiar los archivos extra que hemos creado para hacer la fusión manual y que ya no necesitamos.

[source,console]
----
$ git clean -f
Removing hello.common.rb
Removing hello.ours.rb
Removing hello.theirs.rb
----

[[_checking_out_conflicts]]
===== Sacando Conflictos
// TODO revisar la traducción de checkout

Quizás no estamos contentos con la resolución en este punto por alguna razón, o quizás editar manualmente uno o ambos lados no funcionó del todo bien y necesitamos más contexto.

Cambiemos el ejemplo un poco. Para este ejemplo, tenemos dos ramas más largas que tienen cada una unos cuantos _commits_ en ellas pero que crean un conflicto legitimo en el contenido cuando se fusionan.

[source,console]
----
$ git log --graph --oneline --decorate --all
* f1270f7 (HEAD, master) update README
* 9af9d3b add a README
* 694971d update phrase to hola world
| * e3eb223 (mundo) add more tests
| * 7cff591 add testing script
| * c3ffff1 changed text to hello mundo
|/
* b7dcc89 initial hello world code
----

Ahora tenemos tres _commits_ únicos que están únicamente en la rama `master` y otros tres _commits_ en la rama `mundo`. Si intentamos fusionar la rama `mundo` en la rama `master` aparece un conflicto.

[source,console]
----
$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.
----

Queremos ver cual es el conflicto de fusión. Si abrimos el archivo, veremos algo como esto:

[source,ruby]
----
#! /usr/bin/env ruby

def hello
<<<<<<< HEAD
  puts 'hola world'
=======
  puts 'hello mundo'
>>>>>>> mundo
end

hello()
----

Ambos lados de la fusión añadieron contenido a este archivo, pero algunos de los _commits_ modificaron el archivo en el mismo lugar, lo que causó este conflicto.

Vamos a explorar un par de las herramientas que ahora tienes a tu disposición para determinar como se produjo este conflicto. Tal vez no es obvio cómo debes resolver este conflicto. Necesitas más contexto.

Una herramienta útil es `git checkout` con la opción `--conflict'. Esto volverá a sacar el archivo otra vez y reemplazará los marcadores de conflicto de fusión. Esto puede ser de ayuda si quieres resetear los marcadores e intentar resolverlos de nuevo.

Puedes usar la opción `--conflict` con `diff3` o `merge` (que es la usada por defecto). Si usas `diff3`, Git usará una versión ligeramente distinta de los marcadores de conflicto, no sólo dándote las versiones de ``ours'' y ``theirs'', sino también la versión ``base'' en la línea para darte más contexto.

[source,console]
----
$ git checkout --conflict=diff3 hello.rb
----

Una vez ejecutamos ese comando, el archivo se verá así:

[source,ruby]
----
#! /usr/bin/env ruby

def hello
<<<<<<< ours
  puts 'hola world'
||||||| base
  puts 'hello world'
=======
  puts 'hello mundo'
>>>>>>> theirs
end

hello()
----

Si te gusta este formato, puedes ponerlo por defecto para futuros conflictos de fusión estableciendo la propiedad `merge.conflictstyle` a `diff3`.

[source,console]
----
$ git config --global merge.conflictstyle diff3
----

El comando `git checkout` puede utilizarse también con las opciones `--ours` y `--theirs, que pueden ser una manera rápida de elegir únicamente un lado o el otro sin fusionar nada en absoluto.

Esto puede ser particularmente útil para conflictos en archivos binarios donde simplemente puedes elegir un lado, o donde solamente quieres fusionar ciertos archivos de la otra rama - puedes hacer la fusión y luego sacar ciertos archivos de un lado o del otro antes de hacer el _commit_.

[[_merge_log]]
===== Historial de Fusiones

Otra herramienta útil para resolver conflictos de fusión es `git log`. Esto te puede ayudar a conseguir contexto sobre qué puede haber contribuido a la causa del conflicto. Revisando un poco de la historia para recordar porque dos líneas de desarrollo distintas estaban editando el mismo área de código puede ser de ayuda a veces.

Para conseguir una lista completa de los _commits_ específicos que fueron introducidos por cada rama involucrada en la fusión, podemos usar la sintaxis de ``tres puntos'' que aprendimos en <<_triple_dot>>.

[source,console]
----
$ git log --oneline --left-right HEAD...MERGE_HEAD
< f1270f7 update README
< 9af9d3b add a README
< 694971d update phrase to hola world
> e3eb223 add more tests
> 7cff591 add testing script
> c3ffff1 changed text to hello mundo
----

Esta es una buena lista de _commits_, seis involucrados en total, además sabemos la línea de desarrollo de cada _commit_.

Podemos simplificar esto aún más para que nos de un contexto más específico. Si añadimos la opción `--merge` a `git log`, nos mostrará sólo los commits de cada lado de la fusión que tocan un archivo que esta actualmente en conflicto.

[source,console]
----
$ git log --oneline --left-right --merge
< 694971d update phrase to hola world
> c3ffff1 changed text to hello mundo
----

Si ejecutas ese comando con la opción `-p`, obtienes sólo los diffs del archivo en conflicto. Esto puede ser *muy útil* en darte rápidamente el contexto que necesitas para ayudarte a entender el por qué del conflicto y cómo resolverlo de mejor manera.

===== Formato Combinado de Diffs 

Ya que Git pone en el área de preparación cualquier resultado correcto de una fusión, cuando ejecutas `git diff` cuando estas en un estado de conflicto de fusión, sólo ves lo que esta todavía en conflicto. Esto puede ser de ayuda para que veas lo que queda aún por resolver.

Cuando ejecutas `git diff` justo después de un conflicto de fusión, te dará un información en un formato diff muy particular.

[source,console]
----
$ git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,11 @@@
  #! /usr/bin/env ruby

  def hello
++<<<<<<< HEAD
 +  puts 'hola world'
++=======
+   puts 'hello mundo'
++>>>>>>> mundo
  end

  hello()
----

Este formato se llama ``Diff Combinado'' y te da dos columnas de datos al lado de cada línea. La primera columna te muestra si esa línea es diferente (añadida o eliminada) en el archivo en la rama ``ours'' y en el archivo en tu directorio de trabajo y la segunda columna hace lo mismo entre la copia en la rama ``theirs'' y la copia en tu directorio de trabajo.

Así que en ese ejemplo puedes ver que las líneas `<<<<<<<` y `>>>>>>>` están en la copia del directorio de trabajo pero no están en ninguno de los dos lados de la fusión. Esto tiene sentido porque la herramienta de fusión las metió ahí para nuestro beneficio, pero se supone que debemos eliminarlas.

Si resolvemos el conflicto y ejecutamos `git diff` otra vez, veremos lo mismo, pero un poco mas útil.

[source,console]
----
$ vim hello.rb
$ git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end

  hello()
----

Esto nos muestra que ``hola world'' estaba en nuestro lado pero no en copia del directorio de trabajo, que ``hello mundo'' estaba en su lado pero no en la copia en el directorio de trabajo y por último que ``hola mundo'' no estaba en ninguno de los dos lados pero está ahora en la copia del directorio de trabajo. Esto puede resultar útil revisar antes de confirmar la resolución del conflicto

También puedes obtener esto con `git log` para cualquier fusión después de haberla hecho para ver como se resolvió un conflicto. Git te dará este formato si ejecutas `git show` en un _commit_ de fusión, o si añades la opción `--cc` a un comando git log -p` (que por defecto sólo muestra los parches para _commits_ que no son fusiones).

[source,console]
----
$ git log --cc -p -1
commit 14f41939956d80b9e17bb8721354c33f8d5b5a79
Merge: f1270f7 e3eb223
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri Sep 19 18:14:49 2014 +0200

    Merge branch 'mundo'

    Conflicts:
        hello.rb

diff --cc hello.rb
index 0399cd5,59727f0..e1d0799
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end

  hello()
----

[[_undoing_merges]]
==== Deshaciendo Fusiones

Ahora que ya sabes cómo crear un _commit_ de fusión, probablemente hagas alguna fusión por error.
Una de las grandes ventajas de trabajar con Git es que está bien que cometas errores, porque es posible (y en muchos casos fácil) arreglarlos.

Los _commits_ de fusión no son distintos.
Digamos que empezaste a trabajas en una rama puntual, que accidentalmente la fusionaste en la rama `master, y ahora tu historial de _commits_ se ve así:

._Commit_ de una fusión accidental
image::images/undomerge-start.png[_Commit_ de una fusión accidental.]

Hay dos maneras de plantear este problema, dependiendo del resultado que se quiera obtener. 

===== Arreglar las referencias

Si el _commit_ de fusión no deseado sólo existe en tu repositorio local, la forma más fácil y la mejor solución es mover las ramas de forma que apunten a donde tu quieras. En la mayoría de los casos, si sigues el `git merge` errante con `git reset --hard HEAD~`, esto reseteará los punteros de las ramas de esta forma:

.Historial después de `git reset --hard HEAD~`
image::images/undomerge-reset.png[Historial después de `git reset --hard HEAD~`.]

Hemos visto `reset` antes en <<_git_reset>>, así que no debería ser difícil averiguar lo que está pasando aquí.
Aquí tienes un recordatorio rápido: `reset --hard` normalmente sigue estos pasos:

. Mueve la rama a la que HEAD apunta.
  En este caso, queremos mover `master` a donde estaba antes del _commit_ de fusión (`C6`).
. Hacer que índice luzca como HEAD.
. Hacer que el directorio de trabajo luzca como el índice.

La desventaja de este planteamiento es que está re-escribiendo la historia, lo que puede ser problemático en un repositorio compartido.
Repasa <<_rebase_peril>> para más información sobre lo que puede pasar; la versión corta es que si otras personas tienen los _commits_ que estás sobreescribiendo deberías evitar `reset`.
Este planteamiento tampoco funcionará si se han creado otros _commits_ después de la fusión; moviendo las referencias perderías efectivamente estos nuevos cambios.

[[_reverse_commit]]
===== Deshacer el _commit_

Si mover los punteros de las ramas no te va a funcionar, Git te da la opción de de hacer un nuevo _commit_ que deshaga todos los cambios de uno existente. 

Git llama a esta operación ``revertir'', y este escenario en particular, lo invocarías de esta manera:

[source,console]
----
$ git revert -m 1 HEAD
[master b1d8379] Revert "Merge branch 'topic'"
----

La opción `-m 1` indica que _commit_ padre está en la ``línea principal'' y debe ser mantenido. Cuando invocas una fusión en `HEAD` (`git merge topic`), el nuevo _commit_ tiene dos padres: el primero es `HEAD` (`C6`), y el segundo es la punta de la rama que estas fusionando (`C4`). En este caso, queremos deshacer todos los cambios introducidos por la fusión del padre #2 (`C4`), mientras mantenemos todo el contenido del padre #1 (`C6`).

La historia con el _commit_ revertido esta:

.Historial tras `git revert -m 1`
image::images/undomerge-revert.png[Historial tras `git revert -m 1`.]

El nuevo _commit_ `^M` tiene exactamente el mismo contenido que `C6`, así que desde este punto es como si la fusión nunca hubiese sucedido, excepto que los ahora _commits_ sin fusionar están todavía en el historial de `HEAD`. Git se confundirá si intentas volver a fusionar `topic` en `master` otra vez:

[source,console]
----
$ git merge topic
Already up-to-date.
----

No hay nada en `topic`que no sea accesible desde `master`. Lo que es peor, si añades trabajo nuevo a `topic` y lo intentas fusionar otra vez, Git sólo añadirá los cambios _desde_ la fusión revertida:

.Historial con una mala fusión
image::images/undomerge-revert2.png[Historial con una mala fusión.]

La mejor forma de evitar esto es des-revertir la fusión original, como ahora quieres traer los cambios que fueron revertidos, *y luego* crear un nuevo _commit_ de fusión: 

[source,console]
----
$ git revert ^M
[master 09f0126] Revert "Revert "Merge branch 'topic'""
$ git merge topic
----

.Historial tras refusionar una fusión revertida
image::images/undomerge-revert3.png[Historial tras refusionar una fusión revertida.]

En este ejemplo, `M` y `^M` se cancelan. `^^M` fusiona efectivamente los cambios de `C3` y `C4`, y `C8` fusiona los cambios de `C7`, así que ahora `topic`esta completamente fusionado.

==== Otros Tipos de Fusión

Hasta ahora hemos visto la fusión normal de dos ramas, normalmente se maneja con lo que llamamos la estrategia ``recursiva'' de fusión. Sin embargo, hay otras formas de unir dos ramas. Vamos a repasar algunas de ellas rápidamente.

=====  Preferencia de _Our_ o _Theirs_

Para empezar, hay otra cosa útil que podemos hacer con el modo normal ``recursivo'' de hacer una fusión. Hemos visto las opciones `ignore-all-space` y `ignore-space-change` que se usan con una `-X` pero también podemos decirle a Git que favorezca un lado u otro cuando encuentre un conflicto.

Por defecto, cuando Git encuentra un conflicto entre dos ramas que se fusionan, añadirá marcadores de conflicto de fusión a tu código y marcará el archivo como conflictivo y te permitirá que lo resuelvas. Si prefieres que Git elija un lado específico e ignore el otro en vez de permitirte que resuelvas el conflicto manualmente, puedes usar el comando `merge` con una opción `-Xours` o `-Xtheirs`.

Si Git ve esto, no añadirá marcadores de conflicto. Cualquier diferencia que sea fusionable, la fusionará. Cualquier diferencia que cause un conflicto, simplemente escogerá el lado que especifiques al completo, incluyendo archivos binarios.

Si volvemos a nuestro ejemplo ``hello world'' de antes, podemos ver que fusionar nuestra rama causa conflictos.

[source,console]
----
$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Resolved 'hello.rb' using previous resolution.
Automatic merge failed; fix conflicts and then commit the result.
----

Sin embargo, si ejecutamos la fusión con `-Xours` o `-Xtheirs` no hay conflictos.

[source,console]
----
$ git merge -Xours mundo
Auto-merging hello.rb
Merge made by the 'recursive' strategy.
 hello.rb | 2 +-
 test.sh  | 2 ++
 2 files changed, 3 insertions(+), 1 deletion(-)
 create mode 100644 test.sh
----

En ese caso, en vez que obtener marcadores de conflicto en el archivo con ``hello mundo'' en un lado y ``hola world'' en el otro, simplemente escogerá ``hola world''. Sin embargo, todos los otros cambios no conflictivos de esa rama se fusionarán correctamente.

Esta opción también se puede usar con el comando `git merge-file` que vimos antes ejecutando algo como `git merge-file --ours` para cada fusión de archivo individual.

Si quieres hacer algo así pero no quieres que Git intente fusionar los cambios del otro lado, hay un método más draconiano, que es la _estrategia_ de fusión ``ours''. Esto es distinto de la _opción_ ``ours'' de la fusión recursiva.

Esto básicamente hará una fusión falsa. Registrará un nuevo _commit_ de fusión con ambas ramas como padre, pero no intentará ni revisar la rama que estas uniendo. Simplemente registrará como resultado de la fusión el código exacto de tu rama actual.

[source,console]
----
$ git merge -s ours mundo
Merge made by the 'ours' strategy.
$ git diff HEAD HEAD~
$
----

Puedes ver que no hay ninguna diferencia entre la rama en la que estábamos y el resultado de la fusión.

Esto puede usarse para engañar a Git y que piense que esa rama ya esta fusionada cuando hagas una fusión más adelante. Por ejemplo, imagina que creaste una rama `release` y has hecho trabajo que ahora querrás fusionar en tu rama `master` en algún momento. Mientras tanto tienes que importar una corrección de errores de `master` en la rama `release`. Puedes fusionar la rama de la corrección del error en la rama `release`y también `merge -s ours` la misma rama en tu rama `master` (aunque el arreglo ya este ahí) para que cuando luego fusiones la rama `release` no haya ningún conflicto por la corrección del error.

include::subtree-merges.asc[]
